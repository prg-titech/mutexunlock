package main

import (
	"fmt"
	"sync"
)

func A() {
	var mutex sync.Mutex

	mutex.Lock()
	mutex.Unlock()
} // OK

func B() {
	var mutex sync.Mutex

	mutex.Lock()
	mutex.Unlock()
} // want "missing unlock"

func C() {
	var mutex sync.RWMutex

	mutex.RLock()
	mutex.RUnlock()
} // want "missing unlock"

type S struct {
	mu sync.Mutex
}

func (s *S) ReceiverTest() {
	s.mu.Lock()
	s.mu.Unlock()
}

func (s *S) D() {
	s.mu.Lock()
	s.mu.Unlock()
} // want "missing unlock"

func E() {
	fmt.Println("hello")
} // OK

func F(b bool) {
	var mutex sync.Mutex

	mutex.Lock()

	if b {
		mutex.Unlock()
		return // want "missing unlock"
	}
	mutex.Unlock()
	fmt.Println("here")
}

func G() {
	var mu sync.Mutex

	mu.Lock()
	defer mu.Unlock()

	fmt.Println("aaaa")
} // OK

func H(b bool) {
	var mu sync.Mutex

	mu.Lock()

	if b {
		mu.Unlock()
	}
	fmt.Println("aaaa")
	mu.Unlock()
} // want "missing unlock"

func I(a, b bool) {
	var mu1 sync.Mutex
	mu1.Lock()
	if b {
		mu1.Unlock()
		return
	}
	if a {
		mu1.Unlock()
		return // want "missing unlock"
	}
	mu1.Unlock()
} // want "missing unlock"

func TwoMutexLockAndOneUnlock() {
	var mu1 sync.Mutex
	var mu2 sync.Mutex
	mu1.Lock()
	mu2.Lock()
	fmt.Println("hello")
	mu1.Unlock()
	mu2.Unlock()
} // want "missing unlock"

func LockInFor(l []int) int {
	var mu1 sync.Mutex

	for k, v := range l {
		mu1.Lock()
		if v == 0 {
			// Here it is ok no unlock since mu1 is local, but to alleviate it is better to unlock
			mu1.Unlock()
			return k // want "missing unlock"
		}
		mu1.Unlock()
		// want "missng unlock"
	}

	return -1 // OK
}

var pointerOfMutex = &sync.Mutex{}

func PointerOfMutex() {
	pointerOfMutex.Lock()
	pointerOfMutex.Unlock()
} // want "missing unlock"

func MutexAsArg(mu *sync.Mutex) {
	mu.Lock()
	mu.Unlock()
} // want "missing unlock"
